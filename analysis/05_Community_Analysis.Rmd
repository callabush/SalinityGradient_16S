---
title: "Between sample/ beta diversity of Microbes along a Salinity Gradient"
author: "Calla Bush St George"
date: "`r Sys.Date()`"
output:
  html_document: 
    code_folding: show
    theme: spacelab
    highlight: pygments
    keep_md: no
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      toc_depth: 3
  keep_md: true  
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.path = "../figures/05_Community_Analysis/")
```

# Goals

1. Load in phyloseq data with rooted tree.
2. Evaluate sequencing depth and remove sample.
3. Normalize the read counts between samples.
4. Calculate community dissimilarities. Numbers between 0 and 1. If 0, completely similar versus if they are 1, then they are completely dissimilar. 
    a. *Sorensen*: Presence/ Absence. Weighted by number of shared taxa. Shared species as a binary-valye. Abundance-unweighted. 
    b. *Bray-Curtis*: Relative abundance. Weighted by number of shared taxa. Shared abundant species: abundance weighted. 
    c. *(Abundance) Weighted UNIFRAC*: Consider abundant species and where they fall on the tree. 
5. Visualize the community data with two unconstricted ordinations:
    a. *PCoA*: Linear method. Uses matrix algebra to calculate eigenvalye. Calculate how much variation is explained by each axis.  Can choose to view axis 1, 2, 3, etc. and plot them together. 
    b. *NMDS*: Non-linear method. Collapse multiple axes into two (or three) dimensions. Can see more axes of variation into fewer axes. Always need to report a stress value. (Ideally less than 0.15)
6. Run statistics with PERMANOVA and betadispR.

# Setup

## Load Libraries
```{r load-packages}
#install.packages("vegan")
pacman::p_load(tidyverse, devtools, phyloseq, patchwork, vegan,
               install = FALSE)
```

## Load in colors
```{r load-colors}
station_colors <- c(
  "Shipping Channel" = "dodgerblue4",
  "Aransas Bay" = "dodgerblue2",
  "Copano West" = "#D9CC3C",
  "Copano East" = "#A0E0BA",
  "Mesquite Bay" = "#00ADA7")
```


## Load in data 
```{r load-physeq}
# Load in rooted phylogenetic tree!
load("data/03_Phylogenetic_Tree/phytree_preprocessed_physeq.RData")
unrooted_physeq_rm456
midroot_physeq_rm456
```

# Explore Read Counts

## Raw Read Depth
```{r calculate-seq-depth}
# Sequence depth will inform us on how we want to normalize our data
# Calculate the total number of reads per sample
raw_total_seqs_df <-
  unrooted_physeq_rm456 %>%
  # Calculate the sample read sums
  sample_sums() %>%
  data.frame()

# Name the column
colnames(raw_total_seqs_df)[1] <- "TotalSeqs"

head(raw_total_seqs_df)

# Make a histogram of raw reads
raw_seqs_histogram <-
  raw_total_seqs_df %>%
  ggplot(aes(x = TotalSeqs)) +
  geom_histogram(bins = 50) +
  scale_x_continuous(limits = c(0, 10000)) +
  labs(title = "Raw Sequencing Depth Distribution") + 
  theme_bw()

```

## Remove lowly sequenced sample
```{r low-seq-sample}
raw_rooted_physeq <-
  midroot_physeq_rm456 %>%
  # Remove lowly sequence sample that was outlier in alpha diversity analysis
  subset_samples(names != "20210615-MA-ABB2F") %>%
  # Any ASVs unique to the sample will also be removed 
  prune_taxa(taxa_sums(.) > 0, .)

# Inspect
raw_rooted_physeq

# What is the minimum number of sequences
raw_rooted_physeq %>%
  sample_sums() %>%
  min()

```

## Normalize Read Counts
```{r scale-reads}

### scale_reads function and matround function
#################################################################################### 
# Function to scale reads: http://deneflab.github.io/MicrobeMiseq/ 
# Scales reads by 
# 1) taking proportions
# 2) multiplying by a given library size of n
# 3) rounding 
# Default for n is the minimum sample size in your library
# Default for round is floor

matround <- function(x){trunc(x+0.5)}

scale_reads <- function(physeq, n = min(sample_sums(physeq)), round = "round") {
  
  # transform counts to n
  physeq.scale <- transform_sample_counts(physeq, function(x) {(n * x/sum(x))})
  
  # Pick the rounding functions
  if (round == "floor"){
    otu_table(physeq.scale) <- floor(otu_table(physeq.scale))
  } else if (round == "round"){
    otu_table(physeq.scale) <- round(otu_table(physeq.scale))
  } else if (round == "matround"){
    otu_table(physeq.scale) <- matround(otu_table(physeq.scale))
  }
  
  # Prune taxa and return new phyloseq object
  physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
  
  }

```

Rescale all reads so they all represent the count of the lowest number of sequence reads.
We will expect each sample to have # of reads around 2200

This is where one might decide to use rarefaction to normalize the data. 

## Scale reads and check the distribution of the seq depth
```{r scale-physeq}
min(sample_sums(raw_rooted_physeq))

# Scale reads by the above function
scaled_rooted_physeq <-
  raw_rooted_physeq %>%
  scale_reads(round = "matround")

# Calculate read depth
## Look at total number of sequences in each sample and compare to what we had before

scaled_total_seqs_df <- 
  scaled_rooted_physeq %>%
  sample_sums() %>%
  data.frame()

head(scaled_total_seqs_df)

# Change first column name to be "TotalSeqs"
colnames(scaled_total_seqs_df)[1] <- "TotalSeqs"

# Inspect
head(scaled_total_seqs_df)

# Check range of data
min_seqs <-
  min(scaled_total_seqs_df)
max_seqs <-
 max(scaled_total_seqs_df)
# Range of seqs
max_seqs - min_seqs

# Plot histogram
scaled_total_seqs_df %>%
  ggplot(aes(x = TotalSeqs)) +
  geom_histogram(bins = 50) +
  scale_x_continuous(limits = c(0, 10000)) +
  labs(title = "Scaled Sequencing Depth at 2194") + 
  theme_bw()

head(scaled_total_seqs_df)

```

# Calculate & Visualize Community Dissimiliarity

Exploratory analyses from the Paily & Shankar (2016) paper, which is using unconstrained ordination methods like PCoA. 

## Sorenson PCoA
```{r sorenson-pcoa}
# Calculate sorenson dissimularity: Abundance-unweighted of shared taxa
scaled_soren_pcoa <-
  ordinate(
  physeq = scaled_rooted_physeq,
  method = "PCoA",
  distance = "bray", binary = TRUE)

#str(scaled_soren_pcoa)

# Plot the ordination
plot_ordination(
  physeq = scaled_rooted_physeq,
  ordination = scaled_soren_pcoa,
  color = "station", 
  title = "Sorenson PCoA") + 
  scale_color_manual(values = station_colors) +
  theme_bw()

# PERMANOVA of sorenson
# Make a new object that has sorenson dissimilarity in a matrix
sorenson_distance <-
  phyloseq::distance(scaled_rooted_physeq, method = "bray", binary = TRUE)

str(sorenson_distance)

# Metadata
metadata <- 
  scaled_rooted_physeq %>%
  sample_data() %>%
  data.frame()

#Actually run the PERMANOVA
## Testing if the centroids of the data are similar or different
adonis2(sorenson_distance ~ station, data = metadata)
```



## Bray-Curtis PCoA

## Weighted-Unifrac PCoA

## Bray-Curtis NMDS

# Test for Statistical Significance with PERMANOVA & betadispR

# Session Information
 For Reproducibility
```{r session-info}
#Ensure reproducibility
devtools::session_info()
```
 


